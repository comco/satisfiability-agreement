% Hardness of the monadic logic with equivalenceIn this section we show that the (finite) satisfiability of monadic first-orderlogic with a single equivalence symbol $\Lvp\Fo\nonv1\Eea1\noag$ is$\ceNExpTime2$-hard by reducing the doubly exponential tiling problem to suchsatisfiability. Our strategy is to employ a counter setup of $\szu$ unarypredicate symbols to encode the exponentially many positions of a binaryencoding of a doubly exponentially bounded quantity, encoding the coordinaes ofa cell of the doubly exponential tiling square.Consider the counter setup $\CS(\szu) = \seq{\suu1,\suu2,\dots,\suu\szu}$ for$\szu \in \pNats$. Recall that the intention of a counter setup is to encode anarbitrary exponentially bounded value at every element of a structure.Let $\DS(\szu) = \CS(\szu) + \seq{\sd}$ be a predicate signature enriching$\CS(\szu)$ with the builtin equivalence symbol $\sd$.We will define a system where every $\sd$-equivalence class includesexponentially many cells. These cellswill correspond to the exponentially many positions of the binary encoding of adoubly exponential value for the $\sd$-class. The bit values at each cellposition will be encoded by the cardinality of that cell: bit value $0$ if thecardinality of the cell is $1$ and bit value $1$ if the cardinality is greaterthan $1$. This will allow us to encode a doubly exponential value at each$\sd$-class. Call the data $\data\CS\StrA\ea$, encoded by the counter setupat $\ea$ the \emph{position} of $\ea$.Let $\StrA$ be a $\DS = \DS(\szu)$-structure.\begin{definition}Define the quantifier-free $\vFoF2\DS$-formula $\feqpos\DS(\xx,\yy)$ by:\[  \feqpos\DS(\xx,\yy) = \feq\CS(\xx,\yy).\]\end{definition}Then $\StrA \vDash \feqpos\DS(\ea,\eb)$ iff $\ea$ and $\eb$ are at the samepositions (in possibly distinct $\sd$-classes):$\data\CS\StrA\ea = \data\CS\StrA\eb$.\begin{definition}Define the quantifier-rank-$1$ $\vFoF2\DS$-formula $\fbitO\DS(\xx)$ by:\[  \fbitO\DS(\xx) = \forall\yy \left(  \sd(\yy,\xx) \land \feqpos\DS(\yy,\xx) \limp \yy = \xx\right).\]\end{definition}Then $\StrA \vDash \fbitO\DS(\ea)$ iff the cell of $\ea$ has cardinality $1$.\begin{definition}Define the quantifier-rank-$1$ $\vFoF2\DS$-formula $\fbitI\DS(\xx)$ by:\[  \fbitI\DS(\xx) = \exists\yy \left(  \sd(\yy,\xx) \land \feqpos\DS(\yy,\xx) \land \yy \neq \xx\right).\]\end{definition}Then $\StrA \vDash \fbitI\DS(\ea)$ iff the cell of $\ea$ has cardinality greaterthan $1$.\begin{definition}Define the quantifier-free $\vFoF2\DS$-formula $\fposzero\DS(\xx)$ by:\[  \fposzero\DS(\xx) = \bigwedge_{1 \leq \ii \leq \szu} \lnot\suu\ii(\xx).\]\end{definition}Then $\StrA \vDash \fposzero\DS(\ea)$ iff the position of $\ea$ is $0$.\begin{definition}Define the quantifier-free $\vFoF2\DS$-formula $\fposmax\DS(\xx)$ by:\[  \fposmax\DS(\xx) = \bigwedge_{1 \leq \ii \leq \szu} \suu\ii(\xx).\]\end{definition}Then $\StrA \vDash \fposmax\DS(\ea)$ iff the position of $\ea$ is the largest$\szu$-bit number $\largtbit\szu$.\begin{definition}Define the quantifier-free $\vFoF2\DS$-formula $\fposless\DS(\xx,\yy)$ by:\[  \fposless\DS(\xx,\yy) = \sd(\xx,\yy) \land \fless\CS(\xx,\yy).\]\end{definition}Then $\StrA \vDash \fposless\DS(\ea,\eb)$ iff $\ea$ and $\eb$ are in the same$\sd$-class and the position of $\ea$ is less than the position of $\eb$.\begin{definition}Define the quantifier-free $\vFoF2\DS$-formula $\fpossucc\DS(\xx,\yy)$ by:\[  \fpossucc\DS(\xx,\yy) = \sd(\xx,\yy) \land \fsucc\CS(\xx,\yy).\]\end{definition}Then $\StrA \vDash \fpossucc\DS(\ea,\eb)$ iff $\ea$ and $\eb$ are in the same$\sd$-class and the position of $\eb$ is the successor of the position of$\ea$.\begin{definition}Define the closed $\vFoF2\DS$-sentence $\ffullpos\DS$ by:\begin{align*}  \ffullpos\DS =  \forall\xx\exists\yy \Big(\sd(\yy,\xx) \land \fposzero\DS(\yy)\Big) \land \\  \forall\xx \Big(  \lnot\fposmax\DS(\xx) \limp \exists\yy \fpossucc\DS(\xx,\yy)\Big).\end{align*}\end{definition}The first part of this formula asserts that every $\sd$-class has an element atposition $0$. The second part asserts that if $\ea$ is an element at position$\posp$, that is not the largest possible, there exists an element $\eb$ in thesame $\sd$-class at position $\posp + 1$.Therefore in any model of $\ffullpos\DS$, every $\sd$-class has $2^\szu$ cells.For example, in particular, every $\sd$-class has cardinality at least $2^\szu$.For the rest of the section, suppose that $\StrA \vDash \ffullpos\DS$.\begin{definition}For every $\szu$-bit number $\posp \in \tBitnums\szu$, define the$\vFoF2\DS$-formula $\fposp\DS\posp(\xx)$ recursively by:\[  \fposp\DS0(\xx) = \fposzero\DS(\xx)\]and for $\posp \in [0, \largtbit\szu-1]$:\[  \fposp\DS{(\posp+1)}(\xx) = \exists\yy \Big(\fposp\DS\posp(\yy) \land  \fpossucc\DS(\yy,\xx)\Big).\]In this case, for the formula to be a two-variable formula,the formula $\fposp\DS\posp(\yy)$ is obtained from $\fposp\DS\posp(\xx)$ byswapping all occurences (not only the unbounded ones) of the variables $\xx$ and$\yy$\footnote{this is reminiscent to the process of defining a standardtranslation of monadic logic to the two-variable first-order fragment}.Note that the length of the formula $\fposp\DS\posp(\xx)$ grows linearly as$\posp$ grows.\end{definition}Then $\StrA \vDash \fposp\DS\posp(\ea)$ iff $\posp$ is the position of $\ea$.\begin{definition}Let $\StrA$ be a $\DS$-structure. Let $\relD = \at\StrA\sd$.Define the function$\gls{Data-D-A} : \Ecl\relD \to \tBitstrings{2^\szu}$, assiging a$2^\szu$-bit bitstring to any $\relD$-class $\eclX$ by:\[  \Data\DS\StrA_\posp \eclX = \begin{cases}  1 &\text{if } \data\CS\StrA(\ea) = \posp-1 \text{ implies }   \StrA \vDash \fbitI\DS(\ea)  \text{ for all } \ea \in \eclX  \\  0 &\text{otherwise.}  \end{cases}\]\end{definition}\begin{definition}Define the quantifier-rank-$1$ $\vFoF2\DS$-formula $\gls{fZero-D-x}$ by:\[  \fZero\DS(\xx) = \forall\yy\Big(\sd(\yy,\xx) \limp \fbitO\DS(\yy)\Big).\] \end{definition}Then $\StrA \vDash \fZero\DS(\ea)$ iff the data at the $\relD$-class of $\ea$encodes $0$: $\bdec{\Data\DS\StrA\relD[\ea]} = 0$.\begin{definition}Define the quantifier-rank-$1$ $\vFoF2\DS$-formula $\gls{fMax-D-x}$ by:\[  \fMax\DS(\xx) = \forall\yy \Big(\sd(\yy,\xx) \limp \fbit\DS1(\yy)\Big).\]\end{definition}Then $\StrA \vDash \fZero\DS(\ea)$ iff the data at the $\relD$-class of $\ea$encodes the largest $2^\szu$-bit number:$\bdec{\Data\DS\StrA\relD[\ea]} = \largtbit{2^\szu}$.\begin{definition}Let $\nM \in \tBitnums{2^\szu}$ be a $\tbit$-bit number, where$\tbit = \bsz\nM \leq 2^\szu$.Define the $\vFoF2\DS$-formula $\fDataN\DS\nM(\xx)$ by:\begin{align*}  \fDataN\DS\nM(\xx) =  \forall\yy \biggl(\sd(\yy,\xx) \limp   \bigwedge_{0 \leq \posp < \tbit} \left(\fposp\DS\posp(\yy) \limp  \fbit\DS{(\benc\nM_{\posp+1})}(\yy)\right) \land \\  \biggl. \forall\xx \Big(  \fposp\DS{(\tbit-1)}(\yy) \land \fposless\DS(\yy,\xx) \limp  \fbitO\DS(\xx) \Big)\biggr).\end{align*}\end{definition}The first part of this formula asserts that the bits at the first $\tbit$positions of the $\sd$-class of $\xx$ encode the number $\nM$.The second part asserts that all the remaining bits at larger positions arezeroes.Note that the length of this formula is polynomially bounded by $\tbit$, thebitsize of $\nM$.We have $\StrA \vDash \fDataN\DS\nM(\ea)$ iff the data at the $\relD$-class of$\ea$ encodes $\nM$: $\bdec{\Data\DS\StrA\relD[\ea]} = \nM$.\begin{definition}Define the $\vFoF6\DS$-formula $\fLess\DS(\xx,\yy)$ by:\begin{align}  \fLess\DS(\xx,\yy) = \exists\xxp\exists\yyp\Bigg(  \sd(\xxp,\xx) \land \sd(\yyp,\yy) \land \nonumber \\  \Big(    \feqpos\DS(\xxp,\yyp) \land \fbitO\DS(\xxp) \land \fbitI\DS(\yyp)  \Big) \land \tag{\ref{Less1}} \\  \forall\xxpp \Big( \fposless\DS(\xxp,\xxpp) \limp \exists\yypp  \Big(\sd(\yypp,\yyp) \land \nonumber \\  \feqpos\DS(\yypp,\xxpp) \land (\fbitO\yypp \lequ \fbitO\xxpp)  \Big)\Big)\Bigg). \tag{\ref{Less2}}\end{align}By rearrangement and reusing variables, this can be also written using justthree variables (but not using just two variables).\end{definition}Then $\StrA \vDash \fLess\DS(\ea,\eb)$ iff$\bdec{\Data\DS\StrA\relD[\ea]} < \bdec{\Data\DS\StrA\relD[\eb]}$.\begin{definition}Define the $\vFoF6\DS$-formula $\fSucc\DS(\xx,\yy)$ by:\begin{align}  \fSucc\DS(\xx,\yy) = \exists\xxp\exists\yyp\Bigg(  \sd(\xxp,\xx) \land \sd(\yyp,\yy) \land \nonumber \\  \Big(    \feqpos\DS(\xxp,\yyp) \land \fbitO\DS(\xxp) \land \fbitI\DS(\yyp)  \Big) \land \tag{\ref{Succ1}} \\  \forall\xxpp \Big(\fposless\DS(\xxpp,\xxp) \limp \fbitI\DS(\xxpp)  \Big) \land \tag{\ref{Succ2}} \\  \forall\yypp \Big( \fposless\DS(\yypp,\yyp) \limp \fbitO\DS(\yypp)  \Big) \land \tag{\ref{Succ3}} \\  \forall\xxpp\Big( \fposless\DS(\xxp,\xxpp) \limp \exists\yypp\Big(    \sd(\yypp,\yyp) \land \nonumber \\    \feqpos\DS(\yypp,\xxpp) \land (\fbitO\DS(\yypp) \lequ \fbitO\DS(\xxpp))  \Big)\Big)\Bigg). \tag{\ref{Succ4}}\end{align}By rearrangement and reusing variables, this can be also written using justthree variables (but not using just two variables).\end{definition}Then $\StrA \vDash \fSucc\DS(\ea,\eb)$ iff $\bdec{\Data\DS\StrA\relD[\eb]} = 1 + \bdec{\Data\DS\StrA\relD[\ea]}$.\begin{definition}Define the $\vFoF3\DS$-sentence $\ffullData\DS$ by:\[  \ffullData\DS = \exists\xx \fZero\DS(\xx) \land  \forall\xx \Big(\lnot\fMax\DS(\xx) \limp \exists\yy  \fSucc\DS(\xx,\yy)\Big).\]\end{definition}If $\StrA$ satisfies $\ffullData\DS$ then $\StrA$ contains a $\sd$-class ofencoding any possible data: for every $\nM \in [0,\largtbit{2^\szu}]$,there is a $\relD$-class $\eclX$ such that $\bdec{\Data\DS\StrA\eclX} = \nM$.\begin{definition}Define the $\vFoF4\DS$-formula $\feqData\DS(\xx,\yy)$ by:\begin{align*}  \feqData\DS(\xx,\yy) = \forall\xxp\forall\yyp \Big(  \sd(\xxp,\xx) \land \sd(\yyp,\yy) \land \\ \feqpos\DS(\xxp,\yyp) \limp   (\fbitO\DS(\xxp) \lequ \fbitO\DS(\yyp))\Big).\end{align*}By rearrangement and reusing variables, this can be also written using justthree variables (but not using just two variables).\end{definition}Then $\StrA \vDash \feqData\DS(\xx,\yy)$ iff$\Data\DS\StrA\relD[\ea] = \Data\DS\StrA\relD[\eb]$.\begin{definition}Define the $\vFoF4\DS$-sentence $\falldiffData\DS$ by:\begin{align*}  \falldiffData\DS = \forall\xx \forall\yy\Big( \lnot\sd(\xx,\yy) \limp   \exists\xxp \exists\yyp\Big( \sd(\xxp,\xx) \land \sd(\yyp,\yy)  \land \\  \feqpos\DS(\xxp,\yyp) \land \lnot (\fbitO\DS(\xxp) \lequ  \fbitO\DS(\yyp))\Big)\Big).\end{align*}By rearrangement and reusing variables, this can be also written using justthree variables (but not using just two variables).\end{definition}If $\StrA$ satisfies $\falldiffData\DS$ then all $\relD$-classes in $\StrA$encode different data.% TODO: Add proper glossaries to the formulas of this sectionRecall from \Cref{sec:complexity} that an instance of the \emph{doublyexponential tiling problem} is an initial condition$\icond = \seq{\icondt1,\icondt2,\dots,\icondt\nn} \subseteq \tiles = [1,\kk]$of tiles from the ``Turing-complete'' domino system$\tcdomsys = (\tiles,\horm,\verm)$, where $\horm,\verm \subseteq\tiles\cprod\tiles$ are the horizontal and vertical matching relations.We need to define a predicate signature capable enough to express a doublyexponential grid of tiles. Consider the predicate signature\[  \DS = \seq{\suuu\horm1,\suuu\horm2,\dots,\suuu\horm\nn;  \suuu\verm1,\suuu\verm2,\dots,\suuu\verm\nn;   \suuu\tiles1,\suuu\tiles2,\dots,\suuu\tiles\kk;\sd}.\]It has the following relevant subsignatures:\begin{itemize}  \item $\DS^\horm =   \seq{\suuu\horm1,\suuu\horm2,\dots,\suuu\horm\nn,\sd}$ encodes the  horizontal index of a tile  \item $\DS^\verm =  \seq{\suuu\verm1,\suuu\verm2,\dots,\suuu\verm\nn,\sd}$ encodes the  vertical index of a tile  \item $\DS^{\horm\verm} =  \seq{\suuu\horm1,\suuu\horm2,\dots,\suuu\horm\nn,  \suuu\verm1,\suuu\verm2,\dots,\suuu\verm\nn,\sd}$ encodes the combined  horizontal and vertical index of a tile; we need this to define the full grid  \item $\DS^\tiles = \seq{\suuu\tiles1,\suuu\tiles2,\dots,\suuu\tiles\kk}$  encodes the type of a tile.\end{itemize}Let $\StrA$ be a $\DS$-structure satisfying $\ffullpos{\DS^{\horm\verm}}$ andlet $\relD = \at\StrA\sd$.The sentence\begin{equation}  \ffullData{\DS^{\horm\verm}} \land \falldiffData{\DS^{\horm\verm}}\end{equation}asserts that the $\relD$-classes form a doubly exponential grid.The sentence\begin{equation}  \forall\xx \Big(\bigwedge_{1 \leq \ii \leq \kk} \suuu\tiles\ii(\xx) \limp  \bigwedge_{\ii < \jj \leq \kk} \lnot\suuu\tiles\jj(\xx)\Big)\end{equation}asserts that every element has a unique type.The sentence\begin{equation}  \forall\xx\forall\yy \Big(\sd(\xx,\yy) \limp  \bigwedge_{1 \leq \ii \leq \kk}   (\suuu\tiles\ii(\xx) \lequ \suuu\tiles\ii(\xx))\Big)\end{equation}asserts that all elements in a $\relD$-class have the same type---the type ofthe tile corresponding to that $\relD$-class.For $\jj \in [1,\nn]$, the sentence\begin{equation}  \forall\xx \Big(\fDataN{\DS^\horm}{(\jj-1)}(\xx) \land \fZero{\DS^\verm}(\xx)  \limp \suuu\tiles{\icondt\jj}(\xx)\Big)\end{equation}encodes the initial segment in the first row of the square.The sentence\begin{equation}  \forall\xx\forall\yy \Big(\fSucc{\DS^\horm}(\xx,\yy) \land  \feqData{\DS^\verm}(\xx,\yy) \limp  \bigvee_{(\ii,\jj) \in \horm} \suuu\tiles{\ii}(\xx) \land  \suuu\tiles{\jj}(\yy)\Big)\end{equation}encodes the horizontal matching condition.The sentence\begin{equation}  \forall\xx\forall\yy \Big(\fSucc{\DS^\verm}(\xx,\yy) \land  \feqData{\DS^\horm}(\xx,\yy) \limp  \bigvee_{(\ii,\jj) \in \verm} \suuu\tiles{\ii}(\xx) \land  \suuu\tiles{\jj}(\yy)\Big)\end{equation}encodes the vertical matching condition.Combining these, we obtain:\begin{proposition}The (finite) satisfiability problem for the monadic first-order logic with asingle equivalence symbol $\Lvp\Fo\nonv1\Eea1\noag$ is $\ceNExpTime2$-hard.\end{proposition}