% Hardness of the monadic logic with equivalenceIn this section we show that the (finite) satisfiability of monadic first-orderlogic with a single equivalence symbol $\Lvp\Fo\nonv1\Eea1\noag$ is$\ceNExpTime2$-hard by reducing the doubly exponential tiling problem to suchsatisfiability. Our strategy is to employ a counter setup of $\szu$ unarypredicate symbols to encode the exponentially many positions of a binaryencoding of a doubly exponentially bounded quantity, encoding the coordinaes ofa cell of the doubly exponential tiling square.Consider the counter setup $\CS(\szu) = \seq{\suu1,\suu2,\dots,\suu\szu}$ for$\szu \in \pNats$. Recall that the intention of a counter setup is to encode anarbitrary exponentially bounded value at every element of a structure.Let $\DS(\szu, \sco) = \CS(\szu) + \seq{\sco, \sd}$ be a predicate signatureenriching $\CS(\szu)$ with the \emph{control predicate symbol} $\sco$ and thebuiltin equivalence symbol $\sd$.We will define a system where every $\sd$-equivalence class includesexponentially many cells satisfying the control predicate symbol. These cellswill correspond to the exponentially many positions of the binary encoding of adoubly exponential value for the $\sd$-class. The bit values at each cellposition will be encoded by the cardinality of that cell: bit value $0$ if thecardinality of the cell is $1$ and bit value $1$ if the cardinality is greaterthan $1$.Call the data $\data\CS\StrA\ea$, encoded by the counter setup at $\ea$ the\emph{position} of $\ea$.\begin{definition}Let $\StrA$ be a $\DS = \DS(\szu,\sco)$-structure. Define the quantifier-free$\vFoF2\DS$-formula $\feqpos\DS(\xx,\yy)$ by:\[  \feqpos\DS(\xx,\yy) = \sco(\xx) \land \sco(\yy) \land \feq\CS(\xx,\yy).\]\end{definition}Then $\StrA \vDash \feqpos\DS(\ea,\eb)$ iff $\ea$ and $\eb$ satisfy the controlpredicate and are at the same positions:$\data\CS\StrA\ea = \data\CS\StrA\eb$.\begin{definition}Define the quantifier-rank-$1$ $\vFoF2\DS$-formula $\fbitO\DS(\xx)$ by:\[  \fbitO\DS(\xx) = \sco(\xx) \land \forall\yy   \sco(\yy) \land \sd(\yy,\xx) \land \feq\CS(\yy,\xx)  \limp \yy = \xx.\]\end{definition}Then $\StrA \vDash \fbitO\DS(\ea)$ iff the cell of $\ea$ has cardinality $1$.\begin{definition}Define the quantifier-rank-$1$ $\vFoF2\DS$-formula $\fbitI\DS(\xx)$ by:\[  \fbitI\DS(\xx) = \exists\yy \sco(\yy) \land \sd(\xx,\yy) \land  \feq\CS(\yy,\xx) \land \yy \neq \xx.\]\end{definition}Then $\StrA \vDash \fbitI\DS(\ea)$ iff the cell of $\ea$ has cardinality greaterthan $1$.\begin{definition}Define the quantifier-free $\vFoF2\DS$-formula $\fposzero\DS(\xx)$ by:\[  \fposzero\DS(\xx) = \sco(\xx) \land  \bigwedge_{1 \leq \ii \leq \szu} \lnot\suu\ii(\xx).\]\end{definition}Then $\StrA \vDash \fposzero\DS(\ea)$ iff the position of $\ea$ is $0$.\begin{definition}Define the quantifier-free $\vFoF2\DS$-formula $\fposmax\DS(\xx)$ by:\[  \fposmax\DS(\xx) = \sco(\xx) \land  \bigwedge_{1 \leq \ii \leq \szu} \suu\ii(\xx).\]\end{definition}Then $\StrA \vDash \fposmax\DS(\ea)$ iff the position of $\ea$ is$\largtbit\szu$.\begin{definition}Define the quantifier-free $\vFoF2\DS$-formula $\fpossucc\DS(\xx,\yy)$ by:\[  \fpossucc\DS(\xx,\yy) = \sco(\xx) \land \sco(\yy) \land \sd(\xx,\yy) \land  \fsucc\CS(\xx,\yy).\]\end{definition}Then $\StrA \vDash \fpossucc\DS(\ea,\eb)$ iff $\ea$ and $\eb$ are in the same$\relD$-class and the position of $\eb$ is the successor of the position of$\ea$.\begin{definition}Define the quantifier-free $\vFoF2\DS$-formula $\fposless\DS(\xx,\yy)$ by:\[  \fposless\DS(\xx,\yy) = \sco(\xx) \land \sco(\yy) \land \sd(\xx,\yy) \land  \fless\CS(\xx,\yy).\]\end{definition}Then $\StrA \vDash \fposless\DS(\ea,\eb)$ iff $\ea$ and $\eb$ are in the same$\relD$-class and the position of $\ea$ is less than the position of $\eb$.\begin{definition}For $\posp \in \tBitnums\szu$, define the $\vFoF2\DS$-formula$\fposp\DS\posp(\xx)$ recursively by:\[  \fposp\DS0(\xx) = \fposzero\DS(\xx)\]and for $\posp < \largtbit\szu$:\[  \fposp\DS{(\posp+1)}(\xx) = \exists\yy \fposp\DS\posp(\yy) \land  \fpossucc\DS(\xx,\yy).\]In this case, for the formula to be a two-variable formula,the formula $\fposp\DS\posp(\yy)$ is obtained from $\fposp\DS\posp(\xx)$ byswapping all occurences (not only the unbounded ones) of the variables $\xx$ and$\yy$.Note that the length of the formula $\fposp\DS\posp(\xx)$ is linear in $\posp$.\end{definition}Then $\StrA \vDash \fposp\DS\posp(\ea)$ iff $\posp$ is the position of $\ea$.\begin{definition}Define the closed $\vFoF2\DS$-sentence $\ffullpos\DS$ by:\begin{align*}  \ffullpos\DS =  \left(\forall\yy\exists\xx \sco(\xx) \land \sd(\xx,\yy) \land    \fposzero\DS(\xx)\right) \land \\  \left(  \forall\xx \sco(\xx) \land \lnot\fposmax\DS(\xx) \limp  \exists\yy \fpossucc\DS(\xx,\yy)\right).\end{align*}\end{definition}The first part of this formula asserts that every $\sd$-class has an element atposition $0$. The second part asserts that if $\ea$ is an element at position$\posp$, that is not the largest possible, there exists an element $\eb$ in thesame $\sd$-class at position $\posp + 1$.Therefore in any model of $\ffullpos\DS$, every $\sd$-class has $2^\szu$ cellssatisfying $\sco$. For example, in particular, every $\sd$-class has cardinalityat least $2^\szu$. For the rest of the section, suppose that $\StrA \vDash\ffullpos\DS$.\begin{definition}Let $\StrA$ be a $\DS$-structure. Let $\relD = \at\StrA\sd$.Define the function$\gls{Data-D-A} : \Ecl\relD \to \tBitstrings{2^\szu}$ by:\[  \Data\DS\StrA_\posp \setS = \begin{cases}  1 &\text{if } \data\CS\StrA(\ea) = \posp-1 \text{ implies }   \StrA \vDash \fbitI\DS(\ea)  \text{ for all } \ea \in \setS  \\  0 &\text{otherwise.}  \end{cases}\]\end{definition}\begin{definition}Define the quantifier-rank-$1$ $\vFoF2\DS$-formula $\gls{fZero-D-x}$ by:\[  \fZero\DS(\xx) = \forall\yy \sco(\yy) \land \sd(\yy,\xx) \limp  \fbitO\DS(\yy).\] \end{definition}Then $\StrA \vDash \fZero\DS(\ea)$ iff $\Data\DS\StrA(\ea) = \benc{0}$.\begin{definition}Define the quantifier-rank-$1$ $\vFoF2\DS$-formula $\gls{fMax-D-x}$ by:\[  \fMax\DS(\xx) = \forall\yy \sco(\yy) \land \sd(\yy,\xx) \limp  \fbit1\DS(\yy).\]\end{definition}Then $\StrA \vDash \fZero\DS(\ea)$ iff $\Data\DS\StrA(\ea) =\benc{\largtbit\szu}$.\begin{definition}Let $\nN \in \tBitnums{2^\szu}$ be a $\tbit$-bit number, where$\tbit = \bsz\nN \leq 2^\szu$.Define the $\vFoF2\DS$-formula $\fDataN\DS\nN(\xx)$ by:\begin{align*}  \fDataN\DS\nN(\xx) = \forall\yy \sco(\yy) \land \sd(\yy,\xx) \limp  \forall\xx \sco(\xx) \land \sd(\xx,\yy) \limp \\  \left(\bigwedge_{0 \leq \posp < \tbit} \fposp\DS\posp(\yy) \limp  \fbit\DS{(\benc\nN_{\posp+1})}(\yy)\right) \land \\  \left(\fposp\DS{(\tbit-1)}(\yy) \land \fposless\DS(\yy,\xx) \limp  \fbitO\DS(\xx) \right).\end{align*}\end{definition}The first part of this formula asserts that the bits at the first $\tbit$positions of the $\sd$-class of $\xx$ encode the number $\nN$.The second part asserts that all the remaining bits at larger positions arezeroes.Note that the length of this formula is polynomially bounded by $\tbit$, thebitsize of $\nN$.We have $\StrA \vDash \fDataN\DS\nN(\ea)$ iff $\bdec{\data\DS\StrA(\ea)} = \nN$.\begin{definition}Define the $\vFoF4\DS$-formula $\fSucc\DS(\xx,\yy)$ by:\begin{align}  \fSucc\DS(\xx,\yy) = \exists\xxp\exists\yyp  \sd(\xxp,\xx) \land \sd(\yyp,\yy) \land \nonumber \\  \left(    \feqpos\DS(\xxp,\yyp) \land \fbitO\DS(\xxp) \land \fbitI\DS(\yyp)  \right) \land \tag{\ref{Succ1}} \\  \left(    \forall\xxpp \fposless\DS(\xxpp,\xxp) \limp \fbitI\DS(\xxpp)  \right) \land \tag{\ref{Succ2}} \\  \left(    \forall\yypp \fposless\DS(\yypp,\yyp) \limp \fbitO\DS(\yypp)  \right) \land \tag{\ref{Succ3}} \\  \Big(    \forall\xxpp \fposless\DS(\xxp,\xxpp) \limp \exists\yypp \sd(\yypp,\yyp)    \land \tag{\ref{Succ4}} \\    \feqpos\DS(\yypp,\xxpp) \land (\fbitO\yypp \lequ \fbitO\xxpp)  \Big). \nonumber\end{align}By rearrangement and reusing variables, this can be also written using justthree variables (but not with just two variables).\end{definition}Then $\StrA \vDash \fSucc\DS(\ea,\eb)$ iff $\bdec{\data\DS\StrA(\eb)} = 1 + \bdec{\data\DS\StrA(\ea)}$.\begin{definition}Define the $\vFoF3\DS$-sentence $\ffullData\DS$ by:\[  \ffullData\DS = \exists\xx \fZero\DS(\xx) \land  \forall\xx \lnot\fMax\DS(\xx) \limp \exists\yy \fSucc\DS(\xx,\yy).\]\end{definition}If $\StrA$ satisfies $\ffullData\DS$ then $\StrA$ contains a $\relD$-classhaving data $\benc\nn$ for every $\nn \in [0, \largtbit{2^\szu}]$.\begin{definition}Define the $\vFoF4\DS$-formula $\feqData\DS(\xx,\yy)$ by:\begin{align*}  \feqData\DS(\xx,\yy) = \forall\xxp\forall\yyp  \sd(\xxp,\xx) \land \sd(\yyp,\yy) \land \feqpos\DS(\xxp,\yyp) \limp \\  (\fbitO\DS(\xxp) \lequ \fbitO\DS(\yyp)).\end{align*}By rearrangement and reusing variables, this can be also written using justthree variables (but not with just two variables).\end{definition}Then $\StrA \vDash \feqData\DS(\xx,\yy)$ iff$\data\DS\StrA(\ea) = \data\DS\StrA(\eb)$.\begin{definition}Define the $\vFoF4\DS$-sentence $\falldiffData\DS$ by:\begin{align*}  &\falldiffData\DS = \forall\xx \forall\yy \lnot\sd(\xx,\yy) \limp \\  &\exists\xxp \exists\yyp \sd(\xxp,\xx) \land \sd(\yyp,\yy) \land  \feqpos\DS(\xxp,\yyp) \land \lnot (\fbitO\DS(\xxp) \lequ \fbitO\DS(\yyp)).\end{align*}By rearrangement and reusing variables, this can be also written using justthree variables (but not with just two variables).\end{definition}If $\StrA$ satisfies $\falldiffData\DS$ then all $\relD$-classes in $\StrA$ havedifferent data.% TODO: Add proper glossaries to the formulas of this sectionRecall from \cref{sec:complexity} that an instance of the \emph{doublyexponential tiling problem} is an initial condition$\icond = \seq{\icondt1,\icondt2,\dots,\icondt\nn} \subseteq \tiles = [1,\kk]$of tiles from the ``Turing-complete'' domino system $\tcdomsys = (\tiles,\horm,\verm)$.We need to define a predicate signature capable enough to express a doublyexponential grid of tiles. Consider the predicate signature\[  \DS = \seq{\suuu\horm1,\suuu\horm2,\dots,\suuu\horm\nn;  \suuu\verm1,\suuu\verm2,\dots,\suuu\verm\nn; \sco,\sd;  \suuu\tiles1,\suuu\tiles2,\dots,\suuu\tiles\kk}.\]It has the following relevant subsignatures:\begin{itemize}  \item $\DS^\horm = \DS(\nn,\sco) =  \seq{\suuu\horm1,\suuu\horm2,\dots,\suuu\horm\nn,\sco, \sd}$ encodes the  horizontal index of a tile  \item $\DS^\verm = \DS(\nn,\sco) =  \seq{\suuu\verm1,\suuu\verm2,\dots,\suuu\verm\nn,\sco, \sd}$ encodes the  vertical index of a tile  \item $\DS^{\horm\verm} = \DS(2\nn,\sco) =  \seq{\suuu\horm1,\suuu\horm2,\dots,\suuu\horm\nn,  \suuu\verm1,\suuu\verm2,\dots,\suuu\verm\nn,\sco,\sd}$ encodes the combined  horizontal and vertical index of a tile; we need this to define the full grid  \item $\DS^\tiles = \seq{\suuu\tiles1,\suuu\tiles2,\dots,\suuu\tiles\kk}$  encodes the type of a tile.\end{itemize}Let $\StrA$ be a $\DS$-structure and let $\relD = \at\StrA\sd$.The sentence\begin{equation}  \ffullData{\DS^{\horm\verm}} \land \falldiffData{\DS^{\horm\verm}}\end{equation}asserts that the $\relD$-classes form a doubly exponential grid.The sentence\begin{equation}  \forall\xx \bigwedge_{1 \leq \ii \leq \kk} \suuu\tiles\ii(\xx) \limp  \bigwedge_{\ii < \jj \leq \kk} \lnot\suuu\tiles\jj(\xx)\end{equation}asserts that every element has a unique type.The sentence\begin{equation}  \forall\xx\forall\yy \sd(\xx,\yy) \limp  \bigwedge_{1 \leq \ii \leq \kk} \suuu\tiles\ii(\xx) \lequ \suuu\tiles\ii(\xx)\end{equation}asserts that all elements in a $\relD$-class have the same type---the type ofthe tile corresponding to that $\relD$-class.For $\jj \in [1,\nn]$, the sentence\begin{equation}  \forall\xx \fDataN{\DS^\horm}{(\jj-1)}(\xx) \land \fZero{\DS^\verm}(\xx) \limp  \suuu\tiles{\icondt\jj}(\xx)\end{equation}encodes the initial segment in the first row of the square.The sentence\begin{equation}  \forall\xx\forall\yy \fSucc{\DS^\horm}(\xx,\yy) \land  \feqData{\DS^\verm}(\xx,\yy) \limp  \bigvee_{(\ii,\jj) \in \horm} \suuu\tiles{\ii}(\xx) \land  \suuu\tiles{\jj}(\yy)\end{equation}encodes the horizontal matching condition.The sentence\begin{equation}  \forall\xx\forall\yy \feqData{\DS^\horm}(\xx,\yy) \land  \fSucc{\DS^\verm}(\xx,\yy) \limp  \bigvee_{(\ii,\jj) \in \verm} \suuu\tiles{\ii}(\xx) \land  \suuu\tiles{\jj}(\yy)\end{equation}encodes the vertical matching condition.Combining these, we obtain:\begin{proposition}The (finite) satisfiability problem for the monadic first-order logic with asingle equivalence symbol $\Lvp\Fo\nonv1\Eea1\noag$ is $\ceNExpTime2$-hard.\end{proposition}